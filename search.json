[
  {
    "objectID": "piloting.html",
    "href": "piloting.html",
    "title": "Piloting",
    "section": "",
    "text": "This page is meant to demonstrate some suggested workflows and examples of how the piloting functions may be used in an active mission to help the pilot download basestation files, create monitoring plots, and monitor mission progress.\nAll code on this page combined in the workflow_downloadScript.m in the agate\\example_workflows folder.\nDetails for each piloting function (inputs, outputs, etc) are available within the standard MATLAB-type documentation in the header of each function and include a detailed description, info on input and output arguments, and examples. These details can be pulled up by typing doc function or help function within the MATLAB Command Window.\n\nInitialization\nTo run any of the agate functions, the toolbox must be initialized with a configuration file.\nNo configuration file yet? Go to the Configuration Guide. If agate will be used to download files from the basestation to the local computer, a basestation.cnf file is required and the OPTIONAL - working with the basestation section of the mission configuration file must be completed.\nThe examples on this page include some plotting, so the OPTIONAL - plotting section should be complete. Examples below will also include some outputs for both the PMAR (pm) and WISPR (ws) acoustic systems. Those are specified in the configuration file and the examples below will indicate which system is ‘active’ for each example. This is controlled with the CONFIG.pm.loggers and CONFIG.ws.loggers options in the OPTIONAL - acoustics section of the configuration file.\n% !make sure agate is on the path!\n\n% initialize with specified configuration file, 'agate_config.cnf'\nCONFIG = agate(agate_config.cnf);\n\n% OR\n\n% initialize with prompt to select configuration file\nCONFIG = agate;\nBack to top\n\n\nDownloading files from the basestation\nagate can use SSH to automatically download any new files present on the basestation to a local computer for further processing. The below folder structure is the suggested approach for working with agate and will ensure later functions are looking in the right spots. It may be possible to customize the folder structure but may result in bugs; if that happens, please report them and we can try to fix it!\n% specify the local piloting folder for this trip in CONFIG.path.mission\n% set up nested folders for basestation files and piloting outputs\npath_status = fullfile(CONFIG.path.mission, 'flightStatus'); % where to store output plots/tables\npath_bsLocal = fullfile(CONFIG.path.mission, 'basestationFiles'); % local copy of basestation files\n% make the dirs if they don't exist\nmkdir(path_status);\nmkdir(path_bsLocal);\n\n% download basestation files\ndownloadBasetationFiles(CONFIG, path_bsLocal)\nBack to top\n\n\nCreating a piloting parameters (pp) variable\nMany of the plotting and other piloting-related functions within agate rely on a pp (piloting parameters) variable - a large table with various outputs from the .nc and .log files compiled in one place. Use the extractPilotingParams to create this table.\nThe last argument, preload, is used to specify if the table should be made from scratch (does not load any previously created table), or if a previous table should be loaded and any new dives appended to that table. As more dives occur during a mission, creating a new table each time can get slow, so saving the previous table and setting preload to 1 can save processing time. If the piloting parameters table is saved in the default location shown in the save() step below, then it will be loaded automatically. If it is saved elsewhere, the function will prompt to select the correct .mat to load.\n% create piloting parameters (pp) table from downloaded basestation files\npp = extractPilotingParams(CONFIG, fullfile(CONFIG.path.mission, 'basestationFiles'), ...\nfullfile(CONFIG.path.mission, 'flightStatus'), 0);\n% change last argument from 0 to 1 to load existing data and append new dives/rows\n\n% save it to the default location\nsave(fullfile(CONFIG.path.mission, 'flightStatus', ['diveTracking_' CONFIG.glider '.mat']), 'pp');\nBack to top\n\n\nMid-mission plots\nFor detail on all available plotting functions, see the Plots page. A highlight of those most useful for piloting are below.\nThese plots will be assigned figure numbers as specified in CONFIG.plots.figNumList in the mission configuration file; that is required for the below steps but is commented out by default in the example mission configuration file. By assigning specific figure numbers, when plots are regenerated after subsequent dives, it will overwrite the previous figure rather than create a new one, preventing an overcluttered desktop.\nThe below steps require a pp variable. If it was created already, this first step is not needed.\n% load existing pp table\nload(fullfile(CONFIG.path.mission, 'flightStatus', ['diveTracking_' CONFIG.glider '.mat']))\n\nMap\n…with target waypoints, dives completed thus far, and vector arrows for the currents.\nIn this example, bathymetry is plotted, specified by CONFIG.map.bathyFile. That last argument can be left out to not plot bathymetry (which can be slow depending on the resolution of the selected bathymetry raster). If the last argument is set to 1, a prompt will appear to select the correct bathymetry file.\nThe below example code saves the map both as a .fig file and a .png. The .fig version will be a very large file, if bathymetry is included, but it is useful for reopening in MATLAB and being able to zoom and move around in the plot. The .png is good for a quick easy overview and ease of sharing, but doesn’t allow the interactive zooming that a pilot may need.\nHigh resolution bathymetry TIFF files can be downloaded from NCEI. See Dependecies - Basemap rasters for more info on how to select and download bathymetry rasters.\n% print map **SLOWISH**\n% set the targets file location (this is the default)\ntargetsFile = fullfile(CONFIG.path.mission, 'targets');\n% create the mission map\n% the function will try to pull bathymetry data from the CONFIG.map.bathy setting or will prompt to select one\nmapMissionPath(CONFIG, pp, 'targetsFile', targetsFile);\n\n% save it as a .fig (for zooming)\nsavefig(fullfile(path_status, [CONFIG.glider '_map.fig']))\n% and as a .png (for quick/easy view)\nexportgraphics(gca, fullfile(path_status, [CONFIG.glider '_map.png']), ...\n    'Resolution', 300)\nBack to top\n\n\nMonitoring plots\n…for humidity, internal pressure, battery consumption, power draw, and acoustic system status.\nIndividual pilots may find some or all or none of these plots useful, but here are just a few examples. The example code has the option to save the figures with the print() function, but that is optional. To automatically plot, save, and then close the figures, just add a close command after print (see example with third and fifth plots below).\n% humidity and pressure - figNumList(2)\nplotHumidityPressure(CONFIG, pp)\nprint(fullfile(path_status, [CONFIG.glider  '_humidityPressure.png']), '-dpng')\n\n% battery usage/free space - figNumList(3)\nAH0_24V = 310; % set total available amp hrs\nplotBattUseFreeSpace(CONFIG, pp, AH0_24V)\nprint(fullfile(path_status, [CONFIG.glider '_battUseFreeSpace.png']), '-dpng')\n\n% voltage pack use (power draw by device) - figNumList(4)\nplotVoltagePackUse(CONFIG, pp)\nprint(fullfile(path_status, [CONFIG.glider '_usageByDevice.png']), '-dpng')\nclose \n\n% voltage pack use (power draw by device, normalized by dive duration) - figNumList(5)\nplotVoltagePackUse_norm(CONFIG, pp)\nprint(fullfile(path_status, [CONFIG.glider '_usageByDevice_normalized_.png']), '-dpng')\n\n% minimum reported voltages - figNumList(6)\nplotMinVolt(CONFIG, pp)\nprint(fullfile(path_status, [CONFIG.glider '_minimumVoltage.png']), '-dpng')\n% close\nIf the glider is running a PMAR acoustic system (and CONFIG.pm.loggers = 1 is set in the configuration file), the free space remaining on each SD card will be plotted by plotBattUseFreeSpace. Additionally, storage space used per minute, by dive, and over time can be plotted with plotPmUsed:\n% PMAR space used per minute and over time\nplotPmUsed(CONFIG, pp)\nIf the glider is running a WISPR acoustic system (and CONFIG.ws.loggers = 1 is set in the configuration file), and using the on-board ERMA sperm whale detector, detection events can be plotted for a single dive. The plots show ICI (inter-click-interval) over the event duration and as a histogram. This plot is interactive and allows the user to click backwards through previous dives; a specific dive can be specified in the function call or end can be used to plot the most recent dive. The plot also provides a ‘reference plot’ showing what a true detection event of both a group of sperm whales or an individual sperm whale would look like. This plot can be used by the pilot to compare and validate the incoming detections.\n% plot detection events from the most recent dive\nplotErmaDetections(CONFIG, path_bsLocal, pp.diveNum(end))\nBack to top\n\n\n\nPrinting errors and mission speed and duration information\nThe Seaglider .log file provides a summary of any errors that occurred during each dive, but they are just a list of integers that then have to be compared to a manual (and differ by Rev B vs Rev E!) so there is a function to print out all non-zero errors and a short descriptor of the type. Any dive can be specified in the second argument, or just the most recent dive as shown below.\n% print out errors with info on type, for the most recent dive\nprintErrors(CONFIG, size(pp,1), pp)\nThe printTravelMetrics and printRecoveryMetrics functions calculate several summary values for the glider’s average speed, progress along the trackline, and estimated time of arrival at the recovery point (last waypoint in targets file). These outputs can be printed to the MATLAB Command Window if the last argument is set to 1, otherwise they will be stored in a structure tm.\n% print avg speed and rough estimate of total mission duration\ntm = printTravelMetrics(CONFIG, pp, fullfile(CONFIG.path.mission, 'targets'), 1);\n\n% specify planned recovery date and time\nrecovery = '2023-06-05 19:00:00';\nrecTZ = 'Pacific/Honolulu';\ntm = printRecoveryMetrics(CONFIG, pp, fullfile(CONFIG.path.mission, 'targets'), ...\nrecovery, recTZ, 1);\nBack to top",
    "crumbs": [
      "Piloting"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "agate: Acoustic Glider Analysis Tools and Environment",
    "section": "",
    "text": "Last Update: 02 May 2025\nagate is a collection of MATLAB-based tools for piloting passive acoustic gliders, processing glider positional and environmental data, and analyzing glider-collected passive acoustic data, particularly for surveys of marine mammals.\nIt was designed initially to work with Seagliders but some of the acoustic conversion tools will also work for Slocum or Oceanscout gliders equipped with the WISPR acoustic system.\nThis package is very much under development and is hosted and version controlled on GitHub. My hope is that I will maintain a stable release and then for those interested in the latest functionality, the GitHub repository can be cloned. For those interested in contributing to the package, I suggest creating a fork and using pull requests to contribute.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "agate: Acoustic Glider Analysis Tools and Environment",
    "section": "Background",
    "text": "Background\nThese tools were initially developed for use with passive acoustic glider surveys conducted by the OSU/NOAA CIMERS Bioacoustics Lab. Initial development was for surveys using Seaglider platforms and either the Wideband Intelligent Signal Processor and Recorder (WISPR) or the Passive Miniaturized Acoustic Recorder XL (PMARXL) recording systems.\nNOAA’s Uncrewed Systems Operations Center (UxSOC) funded additional development into a more broadly applicable and user-friendly tool box that could be used by all interested in conducting glider-based passive acoustic surveys for marine mammals.\n\n\n\n\n\n\nFigure 1: Diagram showing the different components of agate. Tools can be broken up into two main categories: piloting tools, which are used for survey planning and execution, and processing tools which are used in post-mission analyses. The processing tools can further be broken up into flight, acoustic, and cetacean encounter processing tools. The cetacean encounter processing tools can incorporate externally identified cetacean detections (white balloon) or process on-board detections if available.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "agate: Acoustic Glider Analysis Tools and Environment",
    "section": "Dependencies",
    "text": "Dependencies\nThis code was either developed or most recently updated and tested with MATLAB version 2022b, but has undergone some testing with 2020b.\n\nMATLAB toolboxes\n\nMapping Toolbox\nagate requires the MATLAB Mapping toolbox. In the future, we may try modify the mapping tools to work with the freely available m_map package to make it more accessible, but are not there yet!\n\n\n\nMATLAB File Exchange\nThis package requires a few resources from MATLAB File Exchange. They come packaged within the utils/fileExchange folder. More info about each can be found below:\n\nSSH/SFTP/SCP For MATLAB (v2)\nDavid Freedman (2023). SSH/SFTP/SCP For Matlab (v2), MATLAB Central File Exchange. Retrieved April 24, 2023.\nLatLon Distance\nM Sohrabinia (2023). LatLon distance, MATLAB Central File Exchange. Retrieved April 24, 2023. \ncmocean\nThyng, Kristen, et al. “True Colors of Oceanography: Guidelines for Effective and Accurate Colormap Selection.” Oceanography, vol. 29, no. 3, The Oceanography Society, Sept. 2016, pp. 9–13, doi:10.5670/oceanog.2016.66.\nseawater_density\nGabriel Ruiz-Martinez (2023). Seawater density from salinity, temperature and pressure, MATLAB Central File Exchange. Retrieved April 24, 2023. \n\n\n\nBasemap rasters\nA raster file is needed to plot bathymetry data on any of the maps. Detailed basemaps are available from NCEI.\nThere are tradeoffs in the resolution of basemap raster selected.\n\nHigh resolution basemaps are necessary for fine-scale piloting to ensure the glider does not hit the bottom, but they require manual export of a .tiff from NCEI. 15 arc second is the finest resolution option and can be extracted for the specific area of interest using the ETOPO Grid Extract tool. The smaller the area extracted, the faster it will load and plot.\nLower resolution may be sufficient for post-mission plotting. The global 60 arc second tiff is a good mid-resolution option that is easy, although slow, to download, import, and plot. Alternatively, 60 arc second resolution for just a specific area of interest can be extracted with the ETOPO Grid Extract tool providing a smaller file size and faster loading/plotting.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#test-dataset",
    "href": "index.html#test-dataset",
    "title": "agate: Acoustic Glider Analysis Tools and Environment",
    "section": "Test dataset",
    "text": "Test dataset\nA small example test dataset for a WISPR-equipped Seaglider is available here. The test dataset includes Seaglider flight files for 10 dives and 10 minutes of raw WISPR acoustic files to test the setup and functionality of agate.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "agate: Acoustic Glider Analysis Tools and Environment",
    "section": "Disclaimer",
    "text": "Disclaimer\nThe scientific results and conclusions, as well as any views or opinions expressed herein, are those of the author(s) and do not necessarily reflect the views of NOAA or the Department of Commerce.\nThis repository is a scientific product and is not official communication of the National Oceanic and Atmospheric Administration, or the United States Department of Commerce. All NOAA GitHub project code is provided on an ‘as is’ basis and the user assumes responsibility for its use. Any claims against the Department of Commerce or Department of Commerce bureaus stemming from the use of this GitHub project will be governed by all applicable Federal law. Any reference to specific commercial products, processes, or services by service mark, trademark, manufacturer, or otherwise, does not constitute or imply their endorsement, recommendation or favoring by the Department of Commerce. The Department of Commerce seal and logo, or the seal and logo of a DOC bureau, shall not be used in any manner to imply endorsement of any commercial product or activity by DOC or the United States Government.\nSoftware code created by U.S. Government employees is not subject to copyright in the United States (17 U.S.C. §105). The United States/Department of Commerce reserves all rights to seek and obtain copyright protection in countries other than the United States for Software authored in its entirety by the Department of Commerce. To this end, the Department of Commerce hereby grants to Recipient a royalty-free, nonexclusive license to use, copy, and create derivative works of the Software outside of the United States.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "mission-processing.html",
    "href": "mission-processing.html",
    "title": "Post-mission processing",
    "section": "",
    "text": "This page is meant to provide some examples of how to run the post-mission processing tools after a mission is complete. These include functions to extract glider surface and dead-reckoned positional data, environmental data, and acoustic recording status into simplified tables for further analysis and some simple summary tables and figures.\nThis page covers four example workflows found in the agate\\example_workflows folder:\n\nworkflow_processPositionalData.m: Extracts glider surface and dead-reckoned sampling locations, environmental data and piloting/orientation data into tables for future analysis. Saves as .mat and .csv. Also creates NCEI-ready location and CTD data tables. Jump to section\nworkflow_acousticEffort.m: Assesses acoustic effort in space and time adding a pam column to the location tables, extracting location and depth for each sound file, and quanitfying effort at a few time scales. Jump to section\nworkflow_missionSummaries.m: Create a summary table with timing, distance, and acoustic effort for multiple gliders Jump to section\nworkflow_plotMultipleGliders.m: Jump to section\n\nDetails for each function used below (inputs, outputs, etc) are available within the standard MATLAB-type documentation in the header of each function and include a detailed description, info on input and output arguments, and examples. These details can be pulled up by typing doc function or help function within the MATLAB Command Window.\n\nInitialization\nTo run any of the agate functions, the toolbox must be initialized with a configuration file.\nNo configuration file yet? Go to the Configuration Guide. The examples on this page include working with acoustic data and plotting so the OPTIONAL - acoustics and OPTIONAL - plotting sections must be complete.\n% make sure agate is on the path!\naddpath(genpath('C:\\Users\\User.Name\\Documents\\MATLAB\\agate'))\n\n% initialize with specified configuration file, 'agate_config.cnf'\nCONFIG = agate('agate_config.cnf');\n\n% OR\n\n% initialize with prompt to select configuration file\nCONFIG = agate;\nBack to top\n\n\nProcess positional data\nThe code in this section follows along with the workflow_processPositionalData.m.\nBack to top\n\nExtract key positional data\nUse the extractPositionalData function to read through all .log and .nc files from the basestation and pull out useful location, depth, environmental, and glider speed and orientation data. Two tables are created: (1) a surface GPS location table with known dive start and end locations and times, and (2) a dead-reckoned/calculated location table with estimated locations when the glider is underwater plus measured environmental data. Underwater location and orientation (latitude, longitude, displacement, speed, glide angle) are calculated on board the glider using two models - the hydrodynamic model and the glide-slope model. Both are extracted from the .nc files; hydrodynamic values have basic column headers like latitude, longitude, and glide-slope model values have _gsm appended to the header name (latitude_gsm, longitude_gsm, etc.). Some environmental and speed values will appear as NA when the glider considers them invalid via an internal QA/QC process.\n%% (1) Extract positional data\n% This step can take some time to process through all .nc files\n\n[gpsSurfT, locCalcT] = extractPositionalData(CONFIG, 1);\n% 0 in plotOn argument will not plot 'check' figures, but change to 1 to\n% plot basic figures for output checking\n\n% save as .mat and .csv\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_gpsSurfaceTable.mat']), 'gpsSurfT');\nwritetable(gpsSurfT,fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_gpsSurfaceTable.csv']))\n\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_locCalcT.mat']),'locCalcT');\nwritetable(locCalcT, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_locCalcT.csv']));\nBack to top\n\n\nSimplify the positional and environmental data for NCEI\nAcoustic data being sent to NCEI for public archiving needs location, depth, and environmental metadata in the data package. This step creates simplified versions of the tables created above in .csv format to be easily packaged with the acoustic files. It creates three tables: (1) a GPS surface location table with start and end time and location for each dive, (2) a calculated location (or dead-reckoned location) table with the dead-reckoned latitude and longitude and measured depth at each glider sample (approx every 10 - 120 seconds depending on the science file loaded on the Seaglider), and (3) a CTD table with the location and depth information in the calculated location table plus temperature, salinity, density, and sound speed at each sample. Note the calculated locations are those calculated using the Seaglider’s hydrodynamic model (as opposed to the glide-slope model) and the CTD table may contain NA values where the data sample was not considered valid.\n%% (2) Simplify positional data for packaging for NCEI\n\n% surface location table\n% load gpsSurfT if not already loaded\nif ~exist('gpsSurfT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_gpsSurfaceTable.mat']));\nend\n\n% clean up columns/names\nkeepCols = {'dive', 'startDateTime', 'startLatitude', 'startLongitude', ...\n    'endDateTime', 'endLatitude', 'endLongitude'};\ngpsSurfSimp = gpsSurfT(:,keepCols);\nnewNames = {'DiveNumber', 'StartDateTime_UTC', 'StartLatitude', 'StartLongitude', ...\n    'EndDateTime_UTC', 'EndLatitude', 'EndLongitude'};\ngpsSurfSimp.Properties.VariableNames = newNames;\n\n% write to csv\nwritetable(gpsSurfSimp, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_GPSSurfaceTableSimple.csv']))\n\n% calculated location table\n% load locCalcT if not already loaded\nif ~exist('locCalcT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_locCalcT.mat']))\nend\n\n% clean up columns/names\nkeepCols = {'dateTime', 'latitude', 'longitude', 'depth', 'dive'};\nlocCalcSimp = locCalcT(:,keepCols);\nnewNames = {'DateTime_UTC', 'Latitude', 'Longitude', 'Depth_m', 'DiveNumber'};\nlocCalcSimp.Properties.VariableNames = newNames;\n\n% write to csv\nwritetable(locCalcSimp, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_CalculatedLocationTableSimple.csv']))\n\n% environmental data\n% load locCalcT if not already loaded\nif ~exist('locCalcT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_locCalcT.mat']))\nend\n\n% clean up columns/names\nkeepCols = {'dive', 'dateTime', 'latitude', 'longitude', 'depth', ...\n    'temperature', 'salinity', 'soundVelocity', 'density'};\nlocCalcEnv = locCalcT(:,keepCols);\nnewNames = {'DiveNumber', 'DateTime_UTC', 'Latitude', 'Longitude', 'Depth_m', ...\n    'Temperature_C', 'Salinity_PSU', 'SoundSpeed_m_s', 'Density_kg_m3', };\nlocCalcEnv.Properties.VariableNames = newNames;\n\n% write to csv\nwritetable(locCalcEnv, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_CTD.csv']))\n\n\nCreate sound speed profile plot\nThe plotSoundSpeedProfile function can create standardized sound speed profiles for each mission.\n%% (3) Plot sound speed profile\n\n% load locCalcT if not already loaded\nif ~exist('locCalcT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.glider, '_', CONFIG.mission, '_locCalcT.mat']))\nend\n\nplotSoundSpeedProfile(CONFIG, locCalcT);\n\n% save as .png and .pdf\nexportgraphics(gcf, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_SSP.png']))\nexportgraphics(gcf, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_SSP.pdf']))\n\n\n\nCalculate acoustic effort\nThe code in this section follows along with the workflow_acousticEffort.m.\nIt requires the sound files to be in .wav or .flac format. See Convert Acoustics for help converting from original .dat raw files to either .wav or .flac.\n\nSummarize acoustic recording status for locations/positions\nUse the extractPAMSatus function to use the timestamp/timing info of each sound file to calculate the total recording duration per dive and mark if the PAM system was on (1) or off (0) for each calculated location/glider data sample. This function can be slow as it runs through every sound file using audioinfo to check the file size and calculate it’s duration. It requires an existing locCalcT and gpsSurfT made above and updates them with a pam column.\n%% (1) Extract acoustic system status for each dive and sample time\n\n% load locCalcT and gpsSurfT if not already loaded\nif ~exist('locCalcT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_locCalcT.mat']))\nend\nif ~exist('gpsSurfT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_gpsSurfaceTable.mat']));\nend\n\n% loop through sound files to gets 'status' for existing positional tables\n[gpsSurfT, locCalcT, pamFiles, pamByDive] = extractPAMStatus(CONFIG, ...\n    gpsSurfT, locCalcT);\n\nfprintf('Total PAM duration: %.2f hours\\n', hours(sum(pamFiles.dur, 'omitnan')));\n\n% save updated positional tables and pam tables\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_pamFiles.mat']), 'pamFiles');\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_pamByDive.mat']), 'pamByDive');\n\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_locCalcT_pam.mat']), 'locCalcT');\nwritetable(locCalcT, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_locCalcT_pam.csv']));\n\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_gpsSurfaceTable_pam.mat']), 'gpsSurfT');\nwritetable(gpsSurfT, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_gpsSurfaceTable_pam.csv']));\nBack to top\n\n\nGet location data for each sound file\nConversely, it can be useful to have a location, depth, and other metrics for each individual sound file if the presence of calls or noise levels are being assessed on a file-by-file bin/granularity. The extractPAMFilePosits function loops through each file and looks for a calculated location/data sample within a defined timeBuffer window of the start of each sound file. The buffer should be set to balance the file duration and the maximum time between samples (as defined in the Seagliders science file). For example, for 10-minute PMAR files with 120-second glider sampling interval, a buffer of 180 seconds is likely good. For a 1-minute WISPR file with 120-second glider sampling interval, a buffer of 80 seconds is likely appropriate.\n%% (2) Extract positional data for each sound file\n\n% load locCalcT and pamFiles if not already loaded\nif ~exist('locCalcT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_locCalcT.mat']))\nend\nif ~exist('pamFiles', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_pamFiles.mat']))\nend\n\n% set a time buffer around which locations are acceptable\ntimeBuffer = 180; % seconds\n% get position at start of each sound file\npamFilePosits = extractPAMFilePosits(pamFiles, locCalcT, timeBuffer);\n\n% save as .mat and .cs \nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_pamFilePosits.mat']), 'pamFilePosits');\nwritetable(pamFilePosits, fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr '_pamFilePosits.csv']));\nBack to top\n\n\nSummarize acoustic effort\nUse the calcPAMEffort function to summarize mission acoustic effort at several scales: by minute, minutes per hour, minutes per day, and hours per day. This prints a few summary statistics to the Command Window and creates tables with minute and hour-sized bins.\nThis and the other acoustic effort\n%% (3) Summarize acoustic effort\n\nif ~exist('gpsSurfT', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_gpsSurfaceTable.mat']))\nend\nif ~exist('pamFiles', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_pamFiles.mat']))\nend\nif ~exist('pamByDive', 'var')\n    load(fullfile(CONFIG.path.mission, 'profiles', ...\n        [CONFIG.gmStr, '_pamByDive.mat']))\nend\n\n% create byMin, minPerHour, minPerDay matrices\n[pamByMin, pamMinPerHour, pamMinPerDay, pamHrPerDay] = calcPAMEffort(...\n    CONFIG, gpsSurfT, pamFiles, pamByDive);\n\n% save it\nsave(fullfile(CONFIG.path.mission, 'profiles', ...\n    [CONFIG.gmStr, '_pamEffort.mat']), ...\n    'pamByMin', 'pamMinPerHour', 'pamMinPerDay', 'pamHrPerDay');\nBack to top\n\n\n\nGenerate mission summaries\nThe code in this section follows along with the workflow_missionSummaries.m. It is expecting the data inputs/outputs to follow the folder structure described in the Set up folder structure section of the Get Started page.\nThis workflow does not actually require agate but the example code could be modified to use a mission configuration file/agate to set the mission/profiles path. Each loop through a mission would just need to load that mission’s configuration file before populating the table. Alternatively, the paths can just be set manually:\n% path to location where each glider's mission folder lives e.g., if \n% gpsSurfT is in C:\\Users\\User.Name\\Desktop\\sgXXX_Mon20XX\\profiles, use:\npath_missions = fullfile('C:\\Users\\User.Name\\Desktop\\');\n% (loop assumes gpsSurfT is within a profiles folder in a mission folder)\n\n% path to save .csvs\npath_out = fullfile('C:\\Users\\User.Name\\Desktop\\', 'project_outputs');\nThen define which missions to include in the summary table.\n% mission strings to include\nmissionStrs = {'sgXXX_Loc_Mon20XX';\n    'sgXXX_Loc_Mon20XX';\n    'sgXXX_Loc_Mon20XX'};\nCreate an empty table and loop through each mission, loading its gpsSurfT and calculating some basic summary statistics. Then save as a .csv.\nout_vars = [{'glider', 'string'}; ...\n    {'startDateTime', 'datetime'}; ...\n    {'endDateTime', 'datetime'}; ...\n    {'numDives', 'double'}; ...\n    {'durDays', 'double'}; ...\n    {'dist_km', 'double'}];\n\nout = table('size', [length(missionStrs), size(out_vars,1)], ...\n    'VariableNames', out_vars(:,1), 'VariableTypes', out_vars(:,2));\n\nfor m = 1:length(missionStrs)\n    missionStr = missionStrs{m};\n    % pull year from string\n    yrStr = missionStr(end-3:end);\n\n    % define path to 'profiles' folder with processed tables\n    path_profiles = fullfile(path_missions, missionStr, 'profiles');\n\n    % load gpsSurfT \n    % (created with agate, using workflow_processPositionalData)\n    load(fullfile(path_profiles, [missionStr '_gpsSurfaceTable.mat']))\n\n    % calculate mission summary stats\n    out.glider{m} = missionStr(1:5);\n    out.startDateTime(m) = gpsSurfT.startDateTime(1);\n    out.endDateTime(m) = gpsSurfT.endDateTime(end);\n    out.numDives(m) = max(gpsSurfT.dive);\n    out.durDays(m) = round(days(out.endDateTime(m)-out.startDateTime(m)));\n    out.dist_km(m) = round(sum(gpsSurfT.distance_km, 'omitnan'), 1);\nend\n\nwritetable(out, fullfile(path_out, 'missionSummaryTable.csv'));\nIf desired, acoustic effort can also be included as total hours recorded and the percent of the total mission with recordings (excluding gaps in recordings when the glider was at the surface or if there was a duty cycle).\nout_vars = [{'recDur_hr', 'double'}; ...\n    %   {'possHrs', 'double'}; ...\n    {'recPercent', 'string'}; ...\n    % {'recDays', 'string'} ...\n    ];\n\n% append to existing table\nout_pam = table('size', [length(missionStrs), size(out_vars,1)], ...\n    'VariableNames', out_vars(:,1), 'VariableTypes', out_vars(:,2));\nout = [out out_pam];\n\nfor m = 1:length(missionStrs)\n    missionStr = missionStrs{m};\n\n    % define path to 'profiles' folder with processed tables\n    path_profiles = fullfile(path_missions, missionStr, 'profiles');\n    % load pam effort tables\n    load(fullfile(path_profiles, [missionStr '_pamEffort.mat']));\n\n    % pam summary stats\n    out.recDur_hr(m) = round(sum(pamMinPerHour.pam, 'omitnan')/60, 1);\n    out.recPercent{m} = sprintf('%i%%', ...\n        round(out.recDur_hr(m)/ ...\n        (hours(out.endDateTime(m) - out.startDateTime(m)))*100));\nend\n\nwritetable(out, fullfile(path_out, 'missionSummaryTable_PAM.csv'));\nBack to top\n\n\nPlot multiple glider tracks\nBack to top",
    "crumbs": [
      "Post-mission processing"
    ]
  },
  {
    "objectID": "plotting.html",
    "href": "plotting.html",
    "title": "Plotting",
    "section": "",
    "text": "This page provides example calls and outputs for each of the plotting functions contained within agate. There are plotting functions that may be useful during mission planning, active piloting, and in post-processing and analysis, and the plots are grouped by those categories below.\nBasic details for each plotting function are available within the standard MATLAB-type documentation in the header of each function and include a detailed description, info on input and output arguments, and examples. These details can be pulled up by typing doc &lt;function&gt; or help &lt;function&gt; within the MATLAB Command Window.",
    "crumbs": [
      "Plotting functions"
    ]
  },
  {
    "objectID": "plotting.html#initialization",
    "href": "plotting.html#initialization",
    "title": "Plotting",
    "section": "Initialization",
    "text": "Initialization\nTo run any of the agate plotting functions, the toolbox must be initialized with a configuration file.\nNo configuration file yet? Go back to Get started - Create configuration files. At a minimum, the configuration file must include the top required portion, as well as the optional - plotting section.\n% ensure agate is on the path\n\n% initialize with specified configuration file, 'agate_config.cnf'\nCONFIG = agate(agate_config.cnf);\n\n% initialize with prompt to select configuration file\nCONFIG = agate;\nMost of the plotting functions rely on a pp (piloting parameters) variable that is a large table with various outputs from the .nc and .log files compiled in one place. If this has already be created, it can be loaded directly. If not, use extractPilotingParams to build it. See the Post-mission Processing page for more detail.\n% load existing pp table\nload(fullfile(CONFIG.path.mission, 'flightStatus', ['diveTracking_' CONFIG.glider '.mat']))\n\n% OR \n\n% create new pp table\npp = extractPilotingParams(CONFIG, fullfile(CONFIG.path.mission, 'basestationFiles'), fullfile(CONFIG.path.mission, 'flightStatus'), 0);\n% zero as last argument creates it from scratch (does not load any previous tables)\nsave(fullfile(CONFIG.path.mission, 'flightStatus', ['diveTracking_' CONFIG.glider '.mat']), 'pp');\nBack to top",
    "crumbs": [
      "Plotting functions"
    ]
  },
  {
    "objectID": "plotting.html#piloting-plots",
    "href": "plotting.html#piloting-plots",
    "title": "Plotting",
    "section": "Piloting plots",
    "text": "Piloting plots\nThe below section of plots is useful during active piloting.\nTo configure default positions for each of these plots, create a cell array with 4-element locations for each plot. They defined [left edge, bottom edge, width, height] in pixels. It can then be saved for later use. The path to this file is defined in the [configuration file](configuration.qmd#optinal-plotting-settings.\nFor example:\npositions{1} = [800, 240, 1000, 700]; \npositions{2} = [1920, 260, 550, 300];\n% etc for up to 9 figures\n\n% save it for later use\nsave('C:\\Users\\User.Name\\Documents\\gliders\\figPositions.mat', 'positions');\n\n% load it if it already exists\nload('C:\\Users\\User.Name\\Documents\\gliders\\figPositions.mat');\n\nHumidity and pressure\nplotHumidityPressure(CONFIG, pp)\n\n\n\nExample humidity and pressure plot.\n\n\n\n\nMinimum voltage\nRev B gliders (e.g., SG639 - left side) will have two lines - one each for the ‘24V’ and ‘10V’ batteries (even if both are 15V), while Rev E gliders (e.g., SG679 - right side) will also have two lines, but the 10V line will primarily remain at 15V and only the 24V line will decrease over the mission.\nplotMinVolt(CONFIG, pp)\n\n\n\n\n\n\nMinimum voltage plot for SG639 (Rev B glider).\n\n\n\n\n\n\n\nMinimum voltage plot for SG679 (Rev E glider).\n\n\n\n\n\n\n\nBattery remaining and PAM free space\nIf the glider is using a PMAR acoustic system, the free space remaining on each SD card will plot with the remaining battery capacity.\nThe 30% battery line and 35 GB PMAR line are hard coded into the plot, but could be modified within the function. The ‘target mission duration’ line is defined by CONFIG.tmd, as set in the configuration file.\n% look up total available amp hours ($AH0_24V parameter; e.g., 310 for 15V system)\nAH0_24V = 310; \nplotBattUseFreeSpace(CONFIG, pp, AH0_24V)\n\n\n\nRemaining battery and PAM storage space for SG639 with PMARXL installed and operating.Note glider battery was not full at start of mission so remaining battery starts at just over 60%.\n\n\n\n\nVoltage use by device\nIf the glider is using a PMAR or WISPR acoustic system, power draw of the acoustic system will be included with measures of pitch, roll, and VBD (variable buoyancy device).\nplotVoltagePackUse(CONFIG, pp)\n\n\n\n\n\n\nEnergy use by device, reported for each dive for SG639 (Rev B glider).\n\n\n\n\n\n\n\nEnergy use by device, reported for each dive for SG679 (Rev E glider).\n\n\n\n\n\n\n\nVoltage use by device, normalized by dive duration\nIf the glider is using a PMAR or WISPR acoustic system, power draw of the acoustic system will be included with measures of pitch, roll, and VBD (variable buoyancy device).\nplotVoltagePackUse_norm(CONFIG, pp)\n\n\n\n\n\n\nEnergy use by device, normalized by dive duration for SG639 (Rev B glider).\n\n\n\n\n\n\n\nEnergy use by device, normalized by dive duration for SG679 (Rev E glider).\n\n\n\n\n\n\n\nMap\nThe map will include the waypoints and track from the targets file and will plot the surface positions of each dive (yellow dots), with red lines connecting surface positions, currents plotted as blue vector arrows, and the next target waypoint with a green circle.\nMap extent (latitude and longitude limits), the location of the north arrow, and the location and scale of the scale bar are all set within the mission configuration file, with example values below. CONFIG.latLim and CONFIG.map.lonLim are required to make the map; the north arrow and scale bar are optional and if those settings do not exist in CONFIG they will not be included in the plot.\nIn this example, bathymetry is plotted, specified by CONFIG.map.bathyFile. That last argument can be left out to not plot bathymetry (which can be slow depending on the resolution of the selected bathymetry raster). If the last argument is set to 1, a prompt will appear to select the correct bathymetry file.\nHigh resolution bathymetry TIFF files can be downloaded from NCEI. See Dependecies - Basemap rasters for more info on how to select and download bathymetry rasters.\ntargetsFile = fullfile(CONFIG.path.mission, 'targets');\n\n% map set up configurations - all should be specified in configuration file \nCONFIG.map.latLim = [40.25 45.00];\nCONFIG.map.lonLim = [-129.50 -123.00];\nCONFIG.map.naLat = 44.4; \nCONFIG.map.naLon = -129;\nCONFIG.map.scalePos = [-0.042 0.775]; \nCONFIG.map.scaleMajor = [0:50:100];\nCONFIG.map.scaleMinor = [0:25:50];\n\n% plot with bathymetry - use file specified in CONFIG or if that does not exist, prompt to select\nmapMissionPath(CONFIG, pp, 'targetsFile', targetsFile);\n\n% plot without bathymetry\nmapMissionPath(CONFIG, pp, 'targetsFile', targetsFile, 'bathy', 0);\n\n\n\nExample piloting map with planned track and waypoints in black, realized track in red with surface positions in yellow, and depth averaged currents as blue vector arrows. The current target waypoint is circled in green.\n\n\nBack to top",
    "crumbs": [
      "Plotting functions"
    ]
  },
  {
    "objectID": "plotting.html#mission-summary-plots",
    "href": "plotting.html#mission-summary-plots",
    "title": "Plotting",
    "section": "Mission summary plots",
    "text": "Mission summary plots\n\nFinal trackline map\n\n\nDive profile\n\n\nSound speed profile",
    "crumbs": [
      "Plotting functions"
    ]
  },
  {
    "objectID": "plotting.html#analysis-plots",
    "href": "plotting.html#analysis-plots",
    "title": "Plotting",
    "section": "Analysis plots",
    "text": "Analysis plots\n\nCetacean event maps",
    "crumbs": [
      "Plotting functions"
    ]
  },
  {
    "objectID": "mission-planning.html",
    "href": "mission-planning.html",
    "title": "Mission planning",
    "section": "",
    "text": "This page is meant to provide some examples of how the mission planning piloting functions maybe be used ahead of a planned mission. The below sections include examples for creating a targets file (the text file list of waypoints to be uploaded to the glider for navigation), creating a planned mission map, plotting a bathymetry profile for the planned track, and summarizing total mission distance and duration.\nAll code on this page is compiled in the workflow_missionTrackPlanning.m in the agate\\example_workflows folder.\nDetails for each function used below (inputs, outputs, etc) are available within the standard MATLAB-type documentation in the header of each function and include a detailed description, info on input and output arguments, and examples. These details can be pulled up by typing doc function or help function within the MATLAB Command Window.\n\nInitialization\nTo run any of the agate functions, the toolbox must be initialized with a configuration file.\nNo configuration file yet? Go to the Configuration Guide. The examples on this page include some plotting, so the OPTIONAL - plotting section must be complete.\n% make sure agate is on the path!\n\n% initialize with specified configuration file, 'agate_config.cnf'\nCONFIG = agate('agate_config.cnf');\n\n% OR\n\n% initialize with prompt to select configuration file\nCONFIG = agate;\nBack to top\n\n\nCreate planned track using Google Earth Pro\nUse Google Earth Pro (the desktop app) to plan a mission trackline and save it as a .kml.\n\nCreate a path object by navigating to the Add menu and selecting Path\nA popup will appear where you can name the path\nWhile the popup is still the top window, the cursor will become a square; can click anywhere on the map to make a waypoint\nContinue to click to make the desired waypoints\nWaypoints can be moved by clicking and dragging\nRight-clicking on a given waypoint will delete it\nView the total track length under the Measurements tab\nOnce you are happy with the track, hit Ok in the popup\n\nThe path must be saved as a .kml containing just a single path/track. To properly save:\n\nWithin Google Earth, right-click on the path name in the panel on the left hand side\nSelect Save place as\nChange the file type from .kmz to .kml and hit Save\n\nAn example is located in agate\\example_workflows\\exampleTrack.kml\n\n\n\n\n\n\nFigure 1: Example path in Google Earth saved as a .kml and ready to be converted to a targets file.\n\n\n\n\n\nCreate targets file from .kml\nThe makeTargetsFile function will read in an existing .kml (that contains a single path) and use it to create a properly formatted Seaglider targets file. The generated targets file will be named targets_ plus the name of the .kml file (e.g., targets_exampleTrack). Note, this file will have no extension, but can be viewed in any text editor. It will contain header information with the glider and mission information defined in CONFIG, the date it was created, and the radius, in meters, as defined with the 'radius' input argument (default is 2000 m).\n/ Targets file for mission sgXXX_Location_Mon20XX\n/ Created on YYYY-mm-dd HH:MM UTC\n/ Deployment will take place at WP01, recovery at RECV\n/ template WPxx lat=DDMM.MMMM lon=DDDMM.MMMM radius=XXXX goto=WPzz\nWaypoint names can be generated one of three ways:\n1. alphanumeric: specify a character string (alpha) prefix in the function call and alphanumeric names will be created automatically. A string 'WP' is the default option.\n2. file: list the desired waypoint names within a simple .txt file, with one name per line and the number of waypoint names must equal the number of waypoints in the .kml; the function will prompt to select the file. An example can be found in agate\\example_workflows\\ExampleTrackWaypointNames.txt\n3. manual: waypoint names are manually entered in the Command window within the function call\n% this function uses name-value pairs for optional arguments. If an argument is \n% not specified, the default will be used\n% CONFIG and kmlFile are not optional, but kmlFile may be set to empty [] to \n% trigger a prompt to select the .kml file \n% Set the waypoint naming via the 'method' argument. The alphanumeric method \n% starting with 'WP' is the default\n% Set the raidus via the 'radius' argument. Default is 2000. \n\n% specify file name to .kml track\nkmlFile = fullfile(CONFIG.path.mission, 'exampleTrack.kml');\n\n% use 1 of 3 options to name waypoints\n\n% (1) alphanumeric/prefix-based automated naming\nalphaNum = 'WPT'; % Any few letters make easy-to-reference and -read options\ntargetsOut = makeTargetsFile(CONFIG, kmlFile, 'method', alphaNum, 'radius', 1000);\n\n% OR\n% (2) use a text file with list of waypoint names; will prompt to select .txt\ntargetsOut = makeTargetsFile(CONFIG, kmlFile, 'method', 'file', 'radius', 1000);\n\n% OR\n% (3) manually enter in command window when prompted\ntargetsOut = makeTargetsFile(CONFIG, kmlFile, 'method', 'manual', 'radius', 1000);\nBack to top\n\n\nPlot planned track\nThe mapPlannedTrack function will create a simple map of the planned track with labeled waypoints. This function requires map extent (lat/lon limits) to be defined in the configuration file. Optionally, a north arrow and scale bar location can be defined in the configuration file. For more help setting those parameters, see the Map Help page.\nNOTE: This function sets the arguments using name-value pairs because most of them are optional. So each is defined by the name of the argument in single quotes (e.g., 'bathy') followed by a comma and then the value for the argument (e.g., 'C:\\bathyFile.tiff'). Use doc mapPlannedTrack to see all possible arguments.\nA bathymetric basemap is optional and is toggled on or off with the bathy argument. Bathymetry will be plotted if bathy is set to 1 or to a fullfile path to a bathymetry .tiff file. The specified file must cover the area of the track. If set to 1 it will first look for a file specified in the configuration file (CONFIG.map.bathyFile) otherwise it will prompt to select a file. See Dependecies - Basemap rasters for more info on how to select and download bathymetry rasters.\nThis function is useful for plotting a single track. If you want to plot multiple tracks in a single figure, use createBaseMap and add the tracks manually. See more on this on the Map Help page.\n% set up map configuration\nbathyOn = 1; % plot bathymetry\n\n% use targetsOut file from above as input targets file\ntargetsFile = targetsOut;\n\n% create plot\ntargetsName = mapPlannedTrack(CONFIG, targetsFile, 'trackName', CONFIG.glider, ...\n   'bathy', bathyOn, 'col_track', 'red');\n% this function uses name-value pairs for optional arguments. \n% CONFIG and targetsFile are not optional, but targetsFile may be set to \n% empty [] to trigger a prompt to select the targets file\n\n% the title will default to CONFIG.glider CONFIG.mission: targetsName\n% This can be very long. To change to whatever you want:\ntitle('Example Planned Track');\n\n% save as .png\nexportgraphics(gcf, fullfile(CONFIG.path.mission, [CONFIG.gmStr ...\n    '_plannedTrack_' targetsName, '.png']), 'Resolution', 300)\n% as .fig\nsavefig(fullfile(CONFIG.path.mission, [CONFIG.gmStr '_plannedTrack_' ...\n    targetsName, '.fig']))\n\n\n\n\n\n\nFigure 2: Example of a planned track map with each waypoint labeled.\n\n\n\nBack to top\n\n\nPlot bathymetry profile\nIt can be useful to have a profile of the bathymetry the planned track will traverse, to highlight periods where the glider’s target dive depth may need to be adjusted more shallow, or can be extended deeper.\nSee Dependecies - Basemap rasters for more info on how to select and download bathymetry rasters.\nAn indicator line (dashed red line) will be plotted at 990 m as the default (max $D_TGT for Seagliders) but can be specified to a different value with the yLine argument.\nNOTE: This function sets the arguments using name-value pairs because most of them are optional. So each is defined by the name of the argument in single quotes (e.g., 'bathyFile') followed by a comma and then the value for the argument (e.g., 'C:\\bathyFile.tiff'). Use doc plotTrackBathyProfile to see all possible arguments.\n% can specify bathymetry file and/or targets file\nbathyFile = 'C:\\GIS\\etopo\\ETOPO2022_ice_15arcsec_OR_wide.tiff';\ntargetsFile = fullfile(CONFIG.path.mission, 'targets_exampleTrack');\n\nplotTrackBathyProfile(CONFIG, 'targetsFile', targetsFile, 'bathyFile', bathyFile);\n\n% OR\n\n% leave that argument out to default to CONFIG.map.bathyFile if\n% available or prompt if not available\nplotTrackBathyProfile(CONFIG, 'targetsFile', targetsFile)\n\n% save as .png\nexportgraphics(gcf, fullfile(CONFIG.path.mission, [CONFIG.gmStr ...\n    '_targetsBathymetryProfile_' targetsName, '.png']), 'Resolution', 300)\n\n\n\n\n\n\nFigure 3: Bathymetry profile for set targets file which shows the seafloor depth at each target and in the straight line between each target. The 990 m depth limit is marked with a dashed line.\n\n\n\n\n\nSummarize planned track\nThe below code reads in an existing (or newly created!) targets file and will loop through to calculate the distance between each waypoint and then print out the total planned track distance. If an estimate of glider speed (in km/day) is available, that can be used to estimate mission duration.\n% if no targetsFile specified, will prompt to select\n[targets, targetsFile] = readTargetsFile(CONFIG);\n% OR specify targetsFile variable from above\n[targets, targetsFile] = readTargetsFile(CONFIG, targetsFile);\n\n% loop through all targets (expect RECV), calc distance between waypoints\nfor f = 1:height(targets) - 1\n    [targets.distToNext_km(f), ~] = lldistkm([targets.lat(f+1) targets.lon(f+1)], ...\n        [targets.lat(f) targets.lon(f)]);\nend\n\n% specify expected avg glider speed in km/day\navgSpd = 15; % km/day\n\n% print out summary\n[targetsPath, targetsName, ~] = fileparts(targetsFile);\nfprintf(1, 'Total tracklength for %s: %.0f km\\n', targetsName, ...\n    sum(targets.distToNext_km));\nfprintf(1, 'Estimated mission duration, at %i km/day: %.1f days\\n', avgSpd, ...\n    sum(targets.distToNext_km)/avgSpd);\nThe output will look something like this:\nTotal tracklength for targets_exampleTrack: 54 km\nEstimated mission duration, at 15 km/day: 3.6 days\nBack to top",
    "crumbs": [
      "Mission planning"
    ]
  },
  {
    "objectID": "wispr-gain-fix.html",
    "href": "wispr-gain-fix.html",
    "title": "WISPR gain fix",
    "section": "",
    "text": "A bug was discovered in WISPR in spring 2023 (should be fixed now??) that leads to sound recordings that look like they have variable gain settings applied on different files. One file would be half as loud as the next (6 dB gain change). For more info on the source/issue with this bug, contact Chris Jones. An imperfect, but workable fix was developed with C. Jones and is included here just in case someone else would find it useful or if the issue arises again in the future. Because this is hopefully one-off issue, the below instructions are an outline/draft of documentation and the included code is not generalized (e.g., hard coded paths, etc.) and is meant to guide a similar effort. Please reach out if you encounter the same problem or need further assistance.\nThis process assumes you have initially converted the .dat files to .wavs, and in looking at those .wavs, noticed an issue. Those ‘bad’ .wavs will be used to make decisions about file gain adjustments so those need to be retained. Then, this process will reconvert the .dat files into .wavs, making adjustments to the expected gain if needed, as assessed following a set of rules or according to manual user input.\nThe general workflow was to work on one dive’s worth of files at a time. That dive’s ‘bad’ .wav files would be opened in Raven so the spectrograms could be visually compared. Jumps in gain are vary obvious as stark changes in noise level from one file to the next. Quieter files are gain settings of ‘1’ and are not changed. The louder files are assumed to have a gain setting of ‘2’ and are reduced to align more with the quieter files.\nA MATLAB script is run for that dive’s worth of files, where .dat files are read in and the noise levels in a specified band are compared. If they are within a similar level, then the gain is assumed to not change and the files are written to .wav as is. If the second file is louder, then it’s gain is adjusted down and this adjusted file is written to .wav format. There are special catches in the script for instances where the noise level between the two files is not a clear 1:1 or 1:2 ratio. In those cases, the script prompts the user to manually assess and specify an adjustment. The user can use the script-generated plots and the spectrograms of the ‘bad’ files to make this decision.\nAll code needed to apply the fix is located in the agate\\scratch\\fixWispr folder.\n\n\nfix_gain.m: This is the primary script to apply the fix. The user must update a few paths and settings and then run this script on a folder of acoustic files. More on running it below\nmy_psd.m: Function to calculate power spectral densities. Results are similar to pwelch but provides outputs normalized by frequency bin size\nplotRMSSpec.m: Function to plot RMS level for two files being compared\nread_wispr_file.m: Function to read a raw WISPR .dat file, extracting all included header info\n\n\n\n\n\nThe fix_gain script is meant to be run over a folder of files. Depending on deployment length, it may be beneficial to work in smaller batches of files. For example, for a 5 week glider mission, we had 40k files which was unreasonable to work with all at once. Plus, when the glider was at the surface there were short gaps in time and so comparing noise levels of files across that time gap may not be appropriate. We found that working on a folder of just the files for a single dive at a time worked well. You could use a different approach but it would require reworking the paths in this script.\nCreate a ‘working’ folder where you will incrementally move the .dat files for just a single dive, process those, then move them out of that folder and replace with the files for the next dive.\nLoad the dive’s worth of ‘bad’ .wavs into Raven (use the Page option to load large amounts of data without crashing Raven) to view the spectrograms in cases where manual assessment is needed.\n\n\n\nWithin the script, several lines of code will need to be changed for your local paths and settings preferences.\n\nLine 48: Specify path to agate folder so all required functions are added to the path\nLine 54: Set verbose to either 'true' or 'false'\n\nverbose = 'true': All prompts and all plots will be generated. The user will need to manually click through every file comparison. This is very useful when first fixing this problem to get a feel for how the files compare, but is time consuming. It is also useful in time periods with a lot of animal noise that could lead to incorrect assumptions of gain changes.\nverbose = 'false': Plots and prompts only appear if a non-standard gain adjustment is detected (not 1 or 2). This enables the script to run mostly hands off except in cases that aren’t clear\n\nLine 57: Set fldrStr to the folder where the dive full of files to be processed will be temporarily moved for processing\nLine 58: Set dive to the dive number to be processed. This is just used in naming the output log files\nLine 59: Set phase to both, ascent, or descent, depending on how many files are being processed. Working on phases individually means more manual moving of files but allows a bit more checking in on the process as it works in smaller chunks\nLine 60: Set path_dat to the folder containing the .dat files to be processed, the temporary ‘working folder’\nLine 61: Set path_out to the overall output folder where the log files and processed .wav files should be saved\nLine 62: Set path_wav for the subfolder (within path_out) to save this dive’s processed files. I had this also print to a ‘working’ folder and then after each dive was processed and those files were checked (viewed in Raven), then they were manually moved out of the working folder into a ‘complete’ folder\nLine 71: Set adc_vref. Default for WISPR is 5\nLine 72: Set nbufs to specify number of buffers to compare (from end of first file to start of second file). For our recording settings, a buffer was 5632 samples, sample rate was 180 kHz, so 96 buffers is just over 3 seconds\nLine 73: Set max_thresh to remove spikes in waveform that could skew the RMS calculations. This is adaptive, so if it is set at 1 and that removes too many datapoints, the process will try to incrementally increase it. This is necessary for periods of glider pumping which are all very loud Lines 78:79, 81: Set spectrum parameters to provide reasonable resolution for a given sampling rate. Larger fft_size will give finer resolution but may lead to ‘spiky’ spectra that aren’t good for comparison\nLines 84:85: Set frequency range (f1 lower limit, f2 upper limit) to compare. Ideal is to select a frequency range a lot of animal or anthropogenic (intermittent/variable) sounds would not be present\n\nThe remaining lines set up the log file, so don’t need to be changed unless the user wants additional information printed out\n\n\n\nHit the green Run button and interact with the script in the Command Window.\nAt the start of a folder, the gain settings for the first two files must always be manually entered, to set the baseline. Use Raven to compare these two files to each other and later files to assess if they are a ‘1’ or ‘2’ (or a combination of those) and manually enter the correct settings.\nAt each prompt, the number should be typed in the command window followed by hitting Enter. The suggested value is in square brackets, but can be confusing/unreliable for the first two files so isn’t necessarily correct. To just accept the suggested value, just hit Enter without typing in new number.\nThe only valid inputs should be ‘1’ or ‘2’. Values that are not one of these will prompt for user assessment.\nIn periods with a lot of dolphins, the script may get confused (noise levels in subsequent 3 seconds can be very different!) so those may require lots of manual assessment.\nIf a wrong key is accidentally pressed or a mistake is made, the best approach is to Quit at the next available prompt. Navigate to the log files and rename them with ‘part1’ or something similar. Move the .dat files that were correctly processed out of the working folder, and then re-run the reduced working folder. This will create new log files at this new starting location, and will overwrite any incorrectly adjusted .wavs. A record of what was adjusted for the earlier files will be saved in the original logs with the appended names.\nBack to top"
  },
  {
    "objectID": "wispr-gain-fix.html#fix-wispr-gain-bug",
    "href": "wispr-gain-fix.html#fix-wispr-gain-bug",
    "title": "WISPR gain fix",
    "section": "",
    "text": "A bug was discovered in WISPR in spring 2023 (should be fixed now??) that leads to sound recordings that look like they have variable gain settings applied on different files. One file would be half as loud as the next (6 dB gain change). For more info on the source/issue with this bug, contact Chris Jones. An imperfect, but workable fix was developed with C. Jones and is included here just in case someone else would find it useful or if the issue arises again in the future. Because this is hopefully one-off issue, the below instructions are an outline/draft of documentation and the included code is not generalized (e.g., hard coded paths, etc.) and is meant to guide a similar effort. Please reach out if you encounter the same problem or need further assistance.\nThis process assumes you have initially converted the .dat files to .wavs, and in looking at those .wavs, noticed an issue. Those ‘bad’ .wavs will be used to make decisions about file gain adjustments so those need to be retained. Then, this process will reconvert the .dat files into .wavs, making adjustments to the expected gain if needed, as assessed following a set of rules or according to manual user input.\nThe general workflow was to work on one dive’s worth of files at a time. That dive’s ‘bad’ .wav files would be opened in Raven so the spectrograms could be visually compared. Jumps in gain are vary obvious as stark changes in noise level from one file to the next. Quieter files are gain settings of ‘1’ and are not changed. The louder files are assumed to have a gain setting of ‘2’ and are reduced to align more with the quieter files.\nA MATLAB script is run for that dive’s worth of files, where .dat files are read in and the noise levels in a specified band are compared. If they are within a similar level, then the gain is assumed to not change and the files are written to .wav as is. If the second file is louder, then it’s gain is adjusted down and this adjusted file is written to .wav format. There are special catches in the script for instances where the noise level between the two files is not a clear 1:1 or 1:2 ratio. In those cases, the script prompts the user to manually assess and specify an adjustment. The user can use the script-generated plots and the spectrograms of the ‘bad’ files to make this decision.\nAll code needed to apply the fix is located in the agate\\scratch\\fixWispr folder.\n\n\nfix_gain.m: This is the primary script to apply the fix. The user must update a few paths and settings and then run this script on a folder of acoustic files. More on running it below\nmy_psd.m: Function to calculate power spectral densities. Results are similar to pwelch but provides outputs normalized by frequency bin size\nplotRMSSpec.m: Function to plot RMS level for two files being compared\nread_wispr_file.m: Function to read a raw WISPR .dat file, extracting all included header info\n\n\n\n\n\nThe fix_gain script is meant to be run over a folder of files. Depending on deployment length, it may be beneficial to work in smaller batches of files. For example, for a 5 week glider mission, we had 40k files which was unreasonable to work with all at once. Plus, when the glider was at the surface there were short gaps in time and so comparing noise levels of files across that time gap may not be appropriate. We found that working on a folder of just the files for a single dive at a time worked well. You could use a different approach but it would require reworking the paths in this script.\nCreate a ‘working’ folder where you will incrementally move the .dat files for just a single dive, process those, then move them out of that folder and replace with the files for the next dive.\nLoad the dive’s worth of ‘bad’ .wavs into Raven (use the Page option to load large amounts of data without crashing Raven) to view the spectrograms in cases where manual assessment is needed.\n\n\n\nWithin the script, several lines of code will need to be changed for your local paths and settings preferences.\n\nLine 48: Specify path to agate folder so all required functions are added to the path\nLine 54: Set verbose to either 'true' or 'false'\n\nverbose = 'true': All prompts and all plots will be generated. The user will need to manually click through every file comparison. This is very useful when first fixing this problem to get a feel for how the files compare, but is time consuming. It is also useful in time periods with a lot of animal noise that could lead to incorrect assumptions of gain changes.\nverbose = 'false': Plots and prompts only appear if a non-standard gain adjustment is detected (not 1 or 2). This enables the script to run mostly hands off except in cases that aren’t clear\n\nLine 57: Set fldrStr to the folder where the dive full of files to be processed will be temporarily moved for processing\nLine 58: Set dive to the dive number to be processed. This is just used in naming the output log files\nLine 59: Set phase to both, ascent, or descent, depending on how many files are being processed. Working on phases individually means more manual moving of files but allows a bit more checking in on the process as it works in smaller chunks\nLine 60: Set path_dat to the folder containing the .dat files to be processed, the temporary ‘working folder’\nLine 61: Set path_out to the overall output folder where the log files and processed .wav files should be saved\nLine 62: Set path_wav for the subfolder (within path_out) to save this dive’s processed files. I had this also print to a ‘working’ folder and then after each dive was processed and those files were checked (viewed in Raven), then they were manually moved out of the working folder into a ‘complete’ folder\nLine 71: Set adc_vref. Default for WISPR is 5\nLine 72: Set nbufs to specify number of buffers to compare (from end of first file to start of second file). For our recording settings, a buffer was 5632 samples, sample rate was 180 kHz, so 96 buffers is just over 3 seconds\nLine 73: Set max_thresh to remove spikes in waveform that could skew the RMS calculations. This is adaptive, so if it is set at 1 and that removes too many datapoints, the process will try to incrementally increase it. This is necessary for periods of glider pumping which are all very loud Lines 78:79, 81: Set spectrum parameters to provide reasonable resolution for a given sampling rate. Larger fft_size will give finer resolution but may lead to ‘spiky’ spectra that aren’t good for comparison\nLines 84:85: Set frequency range (f1 lower limit, f2 upper limit) to compare. Ideal is to select a frequency range a lot of animal or anthropogenic (intermittent/variable) sounds would not be present\n\nThe remaining lines set up the log file, so don’t need to be changed unless the user wants additional information printed out\n\n\n\nHit the green Run button and interact with the script in the Command Window.\nAt the start of a folder, the gain settings for the first two files must always be manually entered, to set the baseline. Use Raven to compare these two files to each other and later files to assess if they are a ‘1’ or ‘2’ (or a combination of those) and manually enter the correct settings.\nAt each prompt, the number should be typed in the command window followed by hitting Enter. The suggested value is in square brackets, but can be confusing/unreliable for the first two files so isn’t necessarily correct. To just accept the suggested value, just hit Enter without typing in new number.\nThe only valid inputs should be ‘1’ or ‘2’. Values that are not one of these will prompt for user assessment.\nIn periods with a lot of dolphins, the script may get confused (noise levels in subsequent 3 seconds can be very different!) so those may require lots of manual assessment.\nIf a wrong key is accidentally pressed or a mistake is made, the best approach is to Quit at the next available prompt. Navigate to the log files and rename them with ‘part1’ or something similar. Move the .dat files that were correctly processed out of the working folder, and then re-run the reduced working folder. This will create new log files at this new starting location, and will overwrite any incorrectly adjusted .wavs. A record of what was adjusted for the earlier files will be saved in the original logs with the appended names.\nBack to top"
  },
  {
    "objectID": "get-started.html",
    "href": "get-started.html",
    "title": "Get started with agate",
    "section": "",
    "text": "This page is meant to help with agate ‘installation’ on your MATLAB path and setting up the necessary configuration files and folder structure plus serve as a quick start guide for some basic commands.\nThis page is not a detailed list of all available functions and their specific documentation (that might be coming later!). Those details are available within the standard MATLAB-type documentation in the header of each function and include a detailed description, info on input and output arguments, and examples. These details can be pulled up by typing doc &lt;function&gt; or help &lt;function&gt; in the MATLAB Command window, replacing &lt;function&gt; with the actual name of the function.",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "get-started.html#installation",
    "href": "get-started.html#installation",
    "title": "Get started with agate",
    "section": "Installation",
    "text": "Installation\n\n\n\n\n\n\nDependencies\n\n\n\nSee the Dependencies section of the home page for more info on the required Mathworks File Exchange packages (copies of these come packaged with agate) and MATLAB Toolbox requirements.\n\n\n\nDownload agate from GitHub\n\nOption 1: Download the latest release\n\nThis option ensures a stable release and removes the requirement of working with GitHub but will need manual updating\nVisit the Releases page and download the latest release source code as a zip or tar.gz file\nUnzip the downloaded folder and place within the default MATLAB directory (e.g., C:\\Users\\User.Name\\Documents\\MATLAB\\). You only need the agate folder (the docs folder contains the files for this website so they can be deleted).\n\nOption 2: Clone the repository using GitHub or GitHub Desktop\n\nThis package is actively being developed and the easiest way stay up to date with the latest improvements is to regularly check for updates from GitHub, but this comes with risks as it may be buggy\nClick on the green Code button and select Open with GitHub Desktop\nSpecify where to clone the cloned local copy. Suggest the default MATLAB directory (e.g., C:\\Users\\User.Name\\Documents\\MATLAB\\)\nFor more help with GitHub see this Git Started Doc\n\nOption 3: Fork the repository using GitHub, then clone your fork via the Option 2 steps above\n\nThis is the best option if you would like to modify the tools and contribute to agate but also stay up to date with the latest developer changes\nClick on the grey Fork button in the upper right and follow the prompts to create a copy of the repository in your personal GitHub account\nFollow the Option 2 steps to clone your fork to your local computer\nIn the future, use the Sync fork button on GitHub to update your fork with any changes in the main repository, while maintaining any of your own modification and use the Contribute button to create pull requests so contribute your modifications to the package\n\nOption 4: Download the repository as a zip file\n\nThis provides the latest functionality before an official release and removes requirement of working with GitHub but will need manual updating\nClick the green Code button at the landing page of the repository and choose Download ZIP\nUnzip the downloaded folder and place within the default MATLAB directory (e.g., C:\\Users\\User.Name\\Documents\\MATLAB\\)\n\n\n\n\nAdd agate to the MATLAB path\n\nOpen MATLAB and click on Set Path in the Environment section of the Home tab (Figure 1)\nIn the Set Path dialog box, choose Add with Subfolders…, select the agate folder, and click Save, then Close (Figure 2)\nThis will now be saved for future MATLAB sessions, but would need to be repeated for any installation on a new computer\n\n\n\n\n\n\n\nFigure 1: Screenshot of MATLAB Home Tab showing where to click to Set Path\n\n\n\n\n\n\n\n\n\nFigure 2: Example screenshot of the Set Path dialog box showing the Add with Subfolders... and Save buttons.\n\n\n\nBack to top",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "get-started.html#quick-start-guide",
    "href": "get-started.html#quick-start-guide",
    "title": "Get started with agate",
    "section": "Quick Start Guide",
    "text": "Quick Start Guide\n\nCreate configuration files\nRunning agate requires a few configuration files. Both of these are plain text files that end with .cnf and can be edited in any text editor or in MATLAB’s Editor window\n\nAn overview mission configuration file for a specific glider/mission\nA basestation configuration file with SSH login info\n\n\nMission configuration file\nAn example configuration file is located in the agate/settings folder: agate_config_example.cnf\nThe configuration file has settings for the glider and mission, paths to relevant input and output folders, map extent and plotting settings, and acoustic system settings. The top section is required to initialize agate and use the most basic functions. The remaining sections are optional depending on what agate functionality is desired. Make a copy and save this file with a unique name for each glider and mission. Descriptions of each configuration item are included in the example file as comments that start with %.\nAdditional info on setting up configuration files can be found in the Configuration file guide.\nTo suggest additional configuration items, please open an issue.\n\n\nBasestation configuration file\nThe path and filename for a basestation configuration file is specified in the mission configuration file. An example is located in the agate/settings folder: basestation_example.cnf.\nThis is a separate configuration file that typically does not change between missions and gliders, and contains potentially sensitive information for the SSH connection to a research group’s basestation. This file should be stored somewhere central and safe, preferably outside of the GitHub repository for security reasons.\nAdditional info on setting up configuration files can be found in the Configuration file guide.\nBack to top\n\n\n\nSet up folder structure\nThe suggested folder structure for working with agate is to specify a ‘mission’ folder, and then within that have a standardized set of nested folders for the various agate inputs and outputs. The path of the ‘mission’ folder is specified by CONFIG.path.mission in the mission configuration file and typically follows the Seaglider naming scheme (e.g., C:\\Users\\User.Name\\Desktop\\sg###_Location_MonYYYY).\nWithin that, should be a flightStatus and a basestationFiles folder; flightStatus will house output figures and tables created during a mission, and basestationFiles is where downloaded basestation files will be saved.\nAdditionally there should be a profiles folder that will house output tables and plots created during post-mission processing.\nThese folders can be set up manually, or created in MATLAB:\n% specify the local piloting/mission folder for this deployment\npath_bsLocal = fullfile(CONFIG.path.mission, 'basestationFiles'); % local copy of basestation files\n\n% make the dirs if they don't exist\nmkdir(path_bsLocal);\nmkdir(fullfile(CONFIG.path.mission, 'flightStatus'); % where to store status outputs );\nmkdir(fullfile(CONFIG.path.mission, 'profiles')); % where to store post-\nBack to top\n\n\nInitialize agate\n\nOpen MATLAB\nAdd the agate folder to the path (with subfolders), if not already done\nType CONFIG = agate(&lt;agate_config.cnf&gt;); in the command window and hit enter\n\nReplace &lt;agate_config.cnf&gt; with the name of your configuration file (e.g., 'agate_config_sg639_testData_Sep2024.cnf')\nIf the configuration file is located within the agate/settings folder, just the name is sufficient. If it is located elsewhere, specify the fullfile path (e.g., 'C:/Users/User.Name/Desktop/agate_config_sgXXX.cnf')\n\nAlternatively, simply type CONFIG = agate; and you will be prompted to select a configuration file\n\n% make sure the agate folder has been added to the path!\n\n% initialize by specifying the configuration file\nCONFIG = agate('agate_config.cnf');\n\n% OR intialize and select the configuration file\nCONFIG = agate;\nBack to top\n\n\nDownload all basestation files\nUse downloadBasestationFiles to automatically download various basestation files to a local machine for further examination. This function requires both a mission configuration file and a basestation configuration file that contains the host url, username, and either a password or paths to an SSH key pair.\nBelow is example code to run this step. This can be saved as a script that makes it easy to re-run each time the glider surfaces, or it can be typed directly into the MATLAB Command Window. The folder structure above must be set up already.\n% initialize agate as above\n\n% make sure the folder structure has been set up to have a mission folder that contains subdirectories 'basestationFiles', 'flightStatus', and 'profiles'\n\n% download basestation files\ndownloadBasestationFiles(CONFIG)\nBack to top\n\n\nExtract select piloting parameters and flight metrics\n%% extract various piloting parameters and values reported by .log file\npp = extractPilotingParams(CONFIG, path_bsLocal, path_status, 0);\n% the last argument (0) indicates that you don't want to preload an existing pp \n% variable that has been saved as a .mat file. Preloading saves time, but should\n% be set to 0 the first time through. Change to 1 after an existing `pp` \n% variable has been saved\n\n% print errors for quick glance/check\npp.ERRORS(end)\n\n% save as .xlsx and .mat \nwritetable(pp, fullfile(path_status, ['diveTracking_' CONFIG.glider '.xlsx'])); % local copy\nsave(fullfile(path_status, ['diveTracking_' CONFIG.glider '.mat']), 'pp');\nBack to top",
    "crumbs": [
      "Get started"
    ]
  },
  {
    "objectID": "contribute.html",
    "href": "contribute.html",
    "title": "How to contribute",
    "section": "",
    "text": "We welcome contributions from the passive acoustic glider community! Help us make this more useful for all. If you would like to contribute to this repository, you can do so in a few ways:\n\nIf you find a bug…\nPlease report an issue on GitHub. Please use the Bug report template.\n\n\nIf you’d like to request a feature or suggest an enhancement (to code or documentation)…\nPlease report an issue on GitHub. There is a Feature request template just for this purpose.\n\n\nIf you’d like to add a feature or fix a bug yourself…\nFork the agate repository. This will create a copy of the repository in your own GitHub account. You can clone this fork to your local machine to work with the toolbox and make changes directly to the code, but also continue to pull changes from the primary repository to stay up to date. Then, when you have a feature you’d like to contribute back to the main repository, you can use a pull request to incorporate those changes.\nWe are happy to help get folks set up with this process, so please reach out with any questions!\n\n\nCoding conventions\nStart reading the existing code to get a hang of our current conventions.\n\nUse camelCase for naming functions\nUse camelCase or underscores _ when naming variables\nAlways put spaces around = when defining variables, after list items and function parameters ([1, 2, 3], not [1,2,3]) and around operators (x + 1, not x+1)\nUse ... to extend function calls onto a second line if it runs beyond 76 characters\n\nFor consistency in documentation, we ask that you use the following templates to create any new functions or scripts:\n\nNew function\nPaste the below code into the top of the new function and updated as needed. Refer to existing functions in the utils folder for examples of what kind of detail to include. Include your name, contact info, and MATLAB version info which can be checked with version. Use spaces for all alignment (not tabs!) to ensure it renders properly with MATLAB documentation pop ups.\nfunction output = newFunction(input)\n% NEWFUNCTION   One-line description here, please\n%\n%   Syntax:\n%       OUTPUT = NEWFUNCTION(INPUT)\n%\n%   Description:\n%       Detailed description here, please\n%\n%   Inputs:\n%       input   describe, please\n%\n%      Outputs:\n%       output  describe, please\n%\n%    Examples:\n%\n%    See also\n%\n%    Authors:\n%       F. Last &lt;first.last@email.com&gt; &lt;https://github.com/username&gt;\n%\n%      Updated:      01 February 2025\n%\n%    Created with MATLAB ver.: 9.13.0.2166757 (R2022b) Update 4\n% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nNew script\nPaste the below code into the top of the new script and fill in the detail as needed. Refer to existing scripts in the example_workflows folder. Please include your name, contact info, and MATLAB version info which can be checked with version.\n% NEWSCRIPT\n%   One-line description here, please\n%\n%   Description:\n%       Detailed description here, please\n%\n%   Notes\n%\n%   See also\n%\n%\n%   Authors:\n%       F. Last &lt;first.last@email.com&gt; &lt;https://github.com/username&gt;\n%\n%   Updated:      01 February 2025\n%\n%   Created with MATLAB ver.: 9.13.0.2166757 (R2022b) Update 4\n% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
    "crumbs": [
      "Contribute"
    ]
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "Development of this toolbox was funded by:\nInitial development - National Defense Science and Engineering Graduate (NDSEG) Fellowship to S. Fregosi’s PhD, Oregon State University\nFurther development - NOAA OMAO Uncrewed Systems Research Transition Office Grant awarded to Pacific Islands Fisheries Science Center and Oregon State University\n\n\n\n\n\n\nFigure 1: Testing and ballasting of SG639 in a saltwater tank before deployment\n\n\n\n Logo by Jennifer McCullough",
    "crumbs": [
      "Acknowledgements"
    ]
  },
  {
    "objectID": "convert-acoustics.html",
    "href": "convert-acoustics.html",
    "title": "Convert acoustic files",
    "section": "",
    "text": "agate includes utilities for converting raw acoustic files (.dat) recorded with either the PMARXL or WISPR acoustic systems into a more easily readable .wav or .flac format. Example workflows for each system are provided in the agate\\example_workflows folder and detailed instructions are below.\nBack to top",
    "crumbs": [
      "Convert acoustic files"
    ]
  },
  {
    "objectID": "convert-acoustics.html#convert-wispr-raw-files",
    "href": "convert-acoustics.html#convert-wispr-raw-files",
    "title": "Convert acoustic files",
    "section": "Convert WISPR raw files",
    "text": "Convert WISPR raw files\n\nDependency references\nEmbedded Ocean Systems, the WISPR developer, has MATLAB and Python tools to work with raw WISPR data available on GitHub: wispr3. An agate user does not need to download or clone this repository but the link is provided here for reference.\nSome functions from wispr3 have been modified to better interface with agate; the modified functions are included within agate and more detailed info on the modifications can be found in a forked version: sfregosi-noaa/wispr3 sf branch.\n\n\nExample workflow\nSee workflow_convertWISPR.m in the example_workflows folder for the basic steps needed to convert a directory (that can include subdirectories) of Seaglider-collected WISPR .dat files into either .flac or .wav files.\n\n\n\n\n\n\nOceanscout or Slocum gliders\n\n\n\nUse the workflow_convertWISPR_hefring.m script for a simplified example to convert WISPR data collected by a Hefring Oceanscout or TWR Slocum glider. This workflow uses a blank or very basic configuration file and ignores some Seaglider specific settings.\n\n\nLike other example workflows, agate must first be initialized with a mission-level configuration file (e.g., agate_config_example.cnf). For the task of converting WISPR files, this can be empty (use agate_config_empty.cnf). But, optionally the CONFIG.ws.inDir and CONFIG.ws.outDir settings in the OPTIONAL - acoustics sections can be set to streamline processing and avoid manual selection of the input and output folders.\nCurrently, the input directory must either be a directory named with the date or a directory full of subdirectories where each subdirectory is named with the date using the format ‘YYMMDD’, (e.g., 230504 for 4 May 2023).\n\n% add agate to the path\naddpath(genpath('C:\\Users\\User.Name\\Documents\\MATLAB\\agate'))\n\n% initialize agate\n% use WISPR Settings section to set in and out paths\nCONFIG = agate('agate_mission_config.cnf');\n\nUse the convertWispr function to run the conversion. The output file type is set with the 'outExt' argument; it can be either '.flac' or '.wav'. Set the 'showProgress' argument to true to print each file name to the Command Window as it is processed. This information is automatically stored in a log file called conversionLog.txt that is saved in the output folder. The log tracks the processing start and end time and will record any files that have to be skipped due to being invalid/empty.\n\n% process all the files!\nconvertWispr(CONFIG, 'showProgress', true, 'outExt', '.flac');\n\nIf the process is interrupted at any point, it is possible to restart at a specified subdirectory. WISPR typically saves raw .dat files in folders by date, named with date in the format YYMMDD, so enter the name of the dated subdirectory as a six digit string to restart there. It will start at the beginning of the directory so any already processed files in that folder will just be reprocessed. Note that the fileheaders.txt file will just append after the restart so some file headers will be repeated. It is possible to just manually delete the to-be-reprocessed files from fileheaders.txt if you don’t want any duplicates.\n\n% restart the process at folder 240919\nconvertWispr(CONFIG, 'showProgress', true, 'outExt', '.flac', ...\n    'restartDir', '240919');\n\nBack to top",
    "crumbs": [
      "Convert acoustic files"
    ]
  },
  {
    "objectID": "convert-acoustics.html#convert-pmar-raw-files",
    "href": "convert-acoustics.html#convert-pmar-raw-files",
    "title": "Convert acoustic files",
    "section": "Convert PMAR raw files",
    "text": "Convert PMAR raw files\n\nDependency references\nA function-ized and modified version of the convertPmar.m script and associated function pmarIn (written by Dave Mellinger and available in the Mathworks File Exchange: convertPmar) are included in agate.\n\n\nExample workflow\nThe script and function have been modified and combined to work within the agate toolbox. The input CONFIG files are populated from a PMAR-specific configuration (.cnf) file. An example can be found in the agate/settings folder.\nSee workflow_convertPMAR.m in the example_workflows folder for a simple example workflow for converting a mission’s PMAR .dat files to .wav.\nLike other workflows in agate it must first be initialized with a mission-level configuration file (e.g., agate_config_example.cnf). Only the top REQUIRED and CONFIG.pm settings in the OPTIONAL - acoustics sections of the configuration file are needed for file conversion.\nAdditionally, a PMAR conversion configuration file (e.g., pmarConvert_example.cnf) is needed. This contains the specific paths and is where you can set your desired conversion settings. Detailed descriptions of each parameter setting are in the example configuration file or can be found on the Configuration - PMAR conversion page.\nBack to top",
    "crumbs": [
      "Convert acoustic files"
    ]
  },
  {
    "objectID": "convert-acoustics.html#wav-to-flac-and-flac-to-wav-conversion",
    "href": "convert-acoustics.html#wav-to-flac-and-flac-to-wav-conversion",
    "title": "Convert acoustic files",
    "section": "WAV to FLAC and FLAC to WAV conversion",
    "text": "WAV to FLAC and FLAC to WAV conversion\nThe tools within agate allow conversion from raw .dat files directly to either .wav. or .flac. Some users may later want to convert between .wav. and .flac. Rather than re-converting the raw .dat files, it is much faster to use flac.exe to encode/decode to/from .flac. There are several ways to do this (free GUIs, command line, MATLAB audioread/audiowrite).\nOne simple and efficient way is to use a MATLAB wrapper-type function available from github.com/sfregosi/myUtils. These two functions (wav2flac and flac2wav) call flac.exe via command line but have the added functionality to operate over a directory of files, check for proper paths, and track progress.\nAfter downloading wav2flac.m and flac2wav.m from myUtils (in the main folder, or can clone the whole repository), add them to the MATLAB path and follow the below example code:\n\n% set path to flac software, input directory of WAV files, output directory for FLAC files\npath_flac = 'C:\\Users\\User.Name\\programs\\flac-1.5.0-win\\Win64\\flac';\n\n% to convert from WAV to FLAC\ninDir = 'F:\\wavFiles';\noutDir = 'F:\\flacFiles\\'; % important it ends in slash! Function has built in check for this\n\nwav2flac(path_flac, inDir, outDir)\n\n% to convert from FLAC to WAV\ninDir = 'F:\\flacFiles';\noutDir = 'F:\\wavFiles\\'; % important it ends in slash! Function has built in check for this\n\nflac2wav(path_flac, inDir, outDir)",
    "crumbs": [
      "Convert acoustic files"
    ]
  },
  {
    "objectID": "map-help.html",
    "href": "map-help.html",
    "title": "Map help",
    "section": "",
    "text": "More coming soon…\nHelp with setting various CONFIG.map parameters."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html#heading-2",
    "href": "about.html#heading-2",
    "title": "About",
    "section": "Heading 2",
    "text": "Heading 2\nRegular text\n\nHeading 3\nRegular text\n\nHeading 4\nRegular text\n\nHeading 5\nRegular text\n\nHeading 6\nRegular text"
  },
  {
    "objectID": "configuration.html",
    "href": "configuration.html",
    "title": "Configuration file guide",
    "section": "",
    "text": "Running agate requires configuration files. Each of these are plain text files that end with .cnf and can be edited in any text editor or in MATLAB’s Editor window.",
    "crumbs": [
      "Configuration guide"
    ]
  },
  {
    "objectID": "configuration.html#mission-configuration-file",
    "href": "configuration.html#mission-configuration-file",
    "title": "Configuration file guide",
    "section": "Mission configuration file",
    "text": "Mission configuration file\nAn example configuration file is located in the agate/settings folder: agate_config_example.cnf\nThe configuration file has settings for the glider and mission, paths to relevant input and output folders, map extent and plotting settings, and acoustic system settings. Lines starting with % are comments.\nThe top section is required to initialize agate and use the most basic functions. The remaining sections are optional depending on what agate functionality is desired, including interfacing with the basestation, working with acoustic data outputs, and plotting maps. Save this file with a unique name for each glider and mission. Descriptions of each configuration item are included in the example file as comments.\nTo suggest additional configuration items, please open an issue.\nBack to top\n\nRequired configuration settings\nThe top section % %%%% REQUIRED CONFIG PARAMETERS %%%%%%%%%%% is required to initialize agate and use the most basic functions. Explanations for each parameter are in the example configuration file as comments.\nCONFIG.glider = 'sgXXX'; % glider serial number\nCONFIG.mission = 'Location_Mon20XX'; % mission identifier defined in sg_calib_constants.m \nCONFIG.sgVer = XX.XX; % 66.12, 66.14, 67.00 or 67.1, firmware version displayed on glider start up\nCONFIG.tmd = XX; % target mission duration in days\n\n% define paths\n% mission path - path to umbrella folder that either contains previously \n%                downloaded basestation and output files or will contain \n%                downloaded and processed/produced files and figures\nCONFIG.path.mission = 'C:\\Users\\User.Name\\Desktop\\sgXXX_Location_Mon20XX\\';\n% analysis path - optional path to an 'analysis' folder that would typically\n%                 contain the outputs of acoustic analyses (e.g., Pamguard\n%                 or Triton)\nCONFIG.path.analysis = 'C:\\Users\\User.Name\\project\\analysis';\n\n\nOptional basestation settings\n% %%%% OPTIONAL - basestation %%%%%%%%%%%%%%%\n% specify basestation configuration file\nCONFIG.bs.cnfFile = 'C:\\Users\\User.Name\\Documents\\gliders\\basestation.cnf';\n% specify path to store downloaded basestation files\nCONFIG.path.bsLocal = fullfile(CONFIG.path.mission, 'basestationFiles\\');\n% specify path to remote files (e.g., glider's current/mission folder)\nCONFIG.path.bsRemote = '/home/jails/group/gliderjail/home/sgXXX/current';\n\n\nOptional acoustics settings\nVarious settings required to operate an acoustic system or to process acoustic data after a mission is over. Depending on which acoustic system is installed, only PMAR or WISPR settings are needed. Unneeded lines can be deleted or ignored by adding a % at the start of the line.\n% %%%% OPTIONAL - acoustics %%%%%%%%%%%%%%%%%\nFor PMAR, some settings are required during a mission to track remaining memory available. The conversion settings are only required after a mission is complete to convert .dat to .wav and should be turned off after conversion is done. The processing and analysis settings are only needed after a mission is complete.\n% PMAR settings\nCONFIG.pm.loggers = 0; % 1 for active, 0 for inactive\nCONFIG.pm.activeCard = 0; % current active card; optional for sgVer 66.12 \n                          % (will be updated in log file automatically);\n                          % necessary to update throughout mission for sgVer 67.0\nCONFIG.pm.numCards = 4; % total number loaded SD cards\n% after mission is complete, set below for raw .dat file conversion\nCONFIG.pm.convert = 0; % 0 during mission or analysis, set 1 to run conversion\nCONFIG.pm.convCnfFile = fullfile(CONFIG.path.mission, 'PMARConvert_sgXXX_Location_MonYYYY.cnf');\n% after mission is complete, set below for data processing/analysis\nCONFIG.pm.fileLength = 600; % in seconds\nCONFIG.pm.sampleRate = 180260; % sample rate\nCONFIG.pm.dateFormat = 'yyMMdd-HHmmss.SSS';\nCONFIG.pm.dateStart = 19; % what character of file name starts the date format\n% example file name: sg639_MHI_Apr2023_230411-185050.484.wav\nWISPR settings are only required for processing and analysis after a mission is complete; there is no agate-based piloting interaction with the WISPR system at this time. The settings define input and output paths and extensions for file conversion and the format of the timestamp in filenames for needed for summarizing recording effort in time and space.\n% WISPR settings\n% only needed after mission is complete (no piloting functionality for WISPR)\nCONFIG.ws.loggers = 0; % 1 for active, 0 for inactive\nCONFIG.ws.inDir = 'D:\\sgXXX_Location_Mon20XX_raw_acoustic_data';   % path to raw .dat files\nCONFIG.ws.outDir = 'E:\\sgXXX_Location_Mon20XX\\flac';   % path to save converted files\nCONFIG.ws.outExt = '.flac';   % determines output format\nCONFIG.ws.fileLength = 60; % in seconds\nCONFIG.ws.dateFormat = 'yyMMdd_HHmmss'; % format of timestamp in filename\nCONFIG.ws.dateStart = 7; % character of filename where date starts\n% example file name: WISPR_230504_202206.flac\n\n\nOptional plotting settings\nIf using agate for plotting during a mission or for analysis and processing after, it is useful to set some plot settings and paths so they don’t have to be repeatedly manually modified.\n% %%%% OPTIONAL - plotting %%%%%%%%%%%%%%%%%%\nFor mapping:\n% maps\n% path to basemap files (land shape files and bathymetry rasters)\nCONFIG.path.shp = 'C:\\Users\\User.Name\\Documents\\GIS\\';\n% optional: can specify full path to bathymetry file, otherwise agate \n% will prompt to select file\nCONFIG.map.bathyFile =  'C:\\Users\\User.Name\\Documents\\GIS\\etopo\\etopo1_ice_g_i2.bin';\n% define map extents and location of map elements\nCONFIG.map.latLim = [000.00 000.00];\nCONFIG.map.lonLim = [-000.00 -000.00];\nCONFIG.map.naLat = 00.00; % optional arguments for north arrow location on map; \n                          % leave empty '[]' for no north arrow\nCONFIG.map.naLon = 000.00;\nCONFIG.map.scalePos = [0 0]; % optional arguments for scale bar location \n                             % and ticks, leave empty '[]' for no scale bar\nCONFIG.map.scaleMajor = [0:50:100];\nCONFIG.map.scaleMinor = [0:12.5:25];\nFor piloting related plots:\nIf piloting plots are being regenerated after each dive, it can be useful to assign them each figure numbers and locations so they are just ‘refreshed’ rather than having new plots created each time resulting in a very cluttered desktop! Each piloting plot has a default order that can be modified with the [0 1 2 3 4 5 6 7 8 9] section of the CONFIG.plots.figNumList. The The position of each plot can also be defined and loaded (allowing for these positions to be saved between missions or to have options when viewing on a laptop or multiple screens). For help setting up a figPositions.mat see the Plotting page.\n% piloting plot settings\n% pre allocate fig numbers so figures are updated rather than created new\nCONFIG.plots.figSeed = 111; % suggest using the glider serial e.g., 639\nCONFIG.plots.figNumList = CONFIG.plots.figSeed + [0 1 2 3 4 5 6 7 8 9]; \n% figNumList (1) = battery, (2) = voltagePackUse, (3) = humidity\n% and pressure, (4) = map, (5) = zoomed map, (6) = minimum voltage, \n% (7) = voltage normalized, (8) = ERMA detections, (9) = ERMA reference\n\n% load plot positions \n% load('C:\\Users\\User.Name\\Documents\\gliders\\figPositions.mat');\n% CONFIG.plots.positions = positions;\nBack to top",
    "crumbs": [
      "Configuration guide"
    ]
  },
  {
    "objectID": "configuration.html#basestation-configuration-file",
    "href": "configuration.html#basestation-configuration-file",
    "title": "Configuration file guide",
    "section": "Basestation configuration file",
    "text": "Basestation configuration file\nThe path and file name for basestation configuration file is specified with CONFIG.bs.cnfFile in the mission configuration file. An example is located in the agate/settings folder: basestation_example.cnf.\nThis is a separate configuration file because it typically does not change between missions and gliders and contains potentially sensitive information for the SSH connection to a research group’s basestation. This file should be stored somewhere central and safe, preferably outside of the GitHub repository for security reasons. This file must contain the below lines, with the inputs updated for a particular basestation. It can work with basestation access via a username and password or a username and SSH key pair to authenticate; the one not used should just be excluded or commented out with a %.\nCONFIG.bs.host = 'url.com';\nCONFIG.bs.username = 'pilot';\n\n% authenticate via password\nCONFIG.bs.password = 'PsWrD';\n% OR key pair\nCONFIG.bs.publicKeyFile  = 'C:/Users/User.Name/.ssh/myPublicKey.pub';\nCONFIG.bs.privateKeyFile = 'C:/Users/User.Name/.ssh/myPrivateKey';\nBack to top\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBack to top",
    "crumbs": [
      "Configuration guide"
    ]
  }
]